# Основы работы с Python

## 1. Списки

Список — это последовательность чисел, строк или других значений. 

Чтобы создать список, нужно:
Написать имя переменной, которая будет содержать список. Например, buttons.
Обрати внимание: имя list в Python зарезервировано. Так не стоит называть переменную. А вот lst или new_list — уже допустимо.
Поставить знак приравнивания =.
Поставить квадратные скобки []. Именно они говорят, что перед тобой список.
Внутри квадратных скобок через запятую перечислить элементы списка.

Список может состоять из элементов разных типов.

## 2. Длина списка и индексы

Для подсчёта элементов списка есть стандартная функция len()

    shopping_list = ['молоко', 'сахар', 'мука', 'яйца', 'разрыхлитель', 'ваниль'] 
    # Всё необходимое уже в тележке
    # Осталось только посчитать
    count = len (shopping_list)
    print(count)


У каждого элемента списка есть порядковый номер — индекс. Зная индекс, можно получить значение элемента списка.

Индексация начинается с 0


## 3. Операции со списками append(), insert() и remove(), pop () и оператор in

Метод — разновидность функции. Его особенность в том, что он привязан к объекту. 

#### Включить новый элемент в конец списка позволяет метод append().

пример:

numbers.append(5)

- То, к чему его нужно применить, — переменная numbers.
- Через точку сам метод — numbers.append().
- В скобках — элемент, который нужно добавить. Получается numbers.append(5).

#### Добавить элемент на указанную позицию: метод insert()

Пример:

hobbits.insert(2, 'Смеагол')

#### Удалить элемент по значению: метод remove()

Пример:

hobbits.remove('Смеагол')

Обрати внимание: метод удаляет не все элементы с подходящим значением, а только первый из них. Он не идёт дальше первого вхождения.

#### Удалить элемент по индексу: метод pop()
Он удаляет элемент по указанному индексу, а также возвращает удалённый элемент.

Если не передать в pop() индекс, метод по умолчанию удалит и вернёт последний элемент.

Значение, которое удаляет pop(), можно сразу добавить в другой список.

Пример:

    lst_1 = ['pen']

    lst_2 = ['apple']

    # Подхватили 'pen', удалили из lst_1, вернули в код и тут же добавили в список lst_2
    lst_2.append(lst_1.pop()) 

    print(lst_1) # Будет напечатано: []

    print(lst_2) # Будет напечатано: ['apple', 'pen']

#### Проверить есть ли элемент в списке поможет оператор in

Пример:

    'Мерри' in hobbits

Если элемент есть в списке, код вернёт True, если его нет — False.

## 4. Сложение списков

К списку можно прибавить другой список. 
Для этого используют оператор +.

Пример:

    # стартовый набор
    hobbits = ['Фродо', 'Сэм', 'Мерри', 'Пиппин']

    # новый набор
    new_members = ['Гэндальф', 'Арагорн']

    # объединение списков
    fellowship = hobbits + new_members

    print(fellowship)

    # Будет напечатано: ['Фродо', 'Сэм', 'Мерри', 'Пиппин', 'Гэндальф', 'Арагорн']

## 5. Списки списков и копирование

пример:

    hobbits = ['Фродо', 'Cэм']

    # по одному на каждого
    eagles = ['Орёл 1', 'Орёл 2']

    # добавили орлов в список
    hobbits.insert(2, eagles)

    print(hobbits)
    # Будет напечатано: ['Фродо', 'Cэм', ['Орёл 1', 'Орёл 2']]

Добавленный список считтается за один элемент.

В Python есть два вида копирования: 
- поверхностное копирование,
- полное, или глубокое копирование.

#### Поверхностное копирование: метод copy()

Вставляются списки скопированного обьекта.

    # список списков
    hobbits = ['Фродо', 'Cэм', ['Орёл 1', 'Орёл 2']]

    # скопировали его
    new_hobbits_list = hobbits.copy()

    # логическим оператором проверили равенство списков:
    print(new_hobbits_list == hobbits)
    # Будет напечатано True

    # Всё получилось —  списки идентичны

    print(new_hobbits_list)
    # Будет напечатано: ['Фродо', 'Cэм', ['Орёл 1', 'Орёл 2']]


При изменении скопированного списка оригинал не меняется.
Но при изменении добавленного списка ['Орёл 1', 'Орёл 2'] оригинал тоже изменится.

Вложенный список с орлами — это изменяемый объект, который существует в оригинальном списке hobbits. Копия ссылается на него.
Когда в копию добавили нового орла, содержание списка изменилось. Поэтому список поменялся и в оригинале.

#### Полное копирование: метод deepcopy()

Вставляются уже не ссылки, а копии объектов из оригинального списка.
После полного копирования можно делать с новым списком что угодно. Изменения не затронут оригинал. 

чтобы его использовать нужно импортировать сначало: from copy import deepcopy

    from copy import deepcopy # импортировали метод deepcopy из модуля copy

    # создали заново список
    hobbits = ['Фродо', 'Cэм', ['Орёл 1', 'Орёл 2']]

    # сделали полную копию 
    new_hobbits_list = deepcopy(hobbits)

    print(hobbits, new_hobbits_list)
    # Будет выведено: ['Фродо', 'Cэм', ['Орёл 1', 'Орёл 2']], ['Фродо', 'Cэм', ['Орёл 1', 'Орёл 2']]

    # теперь изменили копию 
    new_hobbits_list.append('Бильбо')
    new_hobbits_list[2].append('Орёл 3')

    # проверили содержимое списков
    print(new_hobbits_list)
    # Будет выведено: ['Фродо', 'Cэм', ['Орёл 1', 'Орёл 2', 'Орёл 3'], 'Бильбо']

    print(hobbits)
    # Будет выведено: ['Фродо', 'Cэм', ['Орёл 1', 'Орёл 2']]

Метод сopy() работает быстрее, чем deepcopy(). Потому что он не копирует объекты, а только отсылает к ним.

## 6. Циклы

    best_movies = ['Побег из Шоушенка', 'Криминальное чтиво', 'Форрест Гамп', 'Леон', 'Король Лев']

    for movie in best_movies: # Это условие цикла
        print(movie) # А это тело цикла

В условии цикла:
После for — имя переменной, в которую будут по очереди передаваться элементы списка. Эту переменную называют внутренней переменной цикла.
После in — имя списка, который нужно обработать.

#### Тело цикла

Это код, который будет воспроизводиться при каждой итерации цикла. То есть — с каждым элементом списка.

Все строки тела цикла отбиваются от начала строки четырьмя пробелами.

    Побег из Шоушенка # Результат первого круга цикла
    Криминальное чтиво # Результат второго круга цикла
    Форрест Гамп # И так далее
    Леон
    Король Лев

Каждый такой «круг» называют итерацией цикла. 

## 7. Диапазоны от и до

#### Функция range()

В эту функцию передают два целых числа: начало и конец диапазона. Первое число должно быть меньше второго. Например, 1 и 1 000.

Функция создаёт последовательность. В неё включаются все целые числа в диапазоне, кроме последнего.

Вот последовательность из двадцати чисел:

    twenty = range(1, 21)
    # Последовательность чисел от 1 до 20
    # 21 тоже на борт не возьмут

У функции range() есть четыре особенности. Они упрощают работу с ней

1) Если последовательность начинается с нуля, можно указать только конец диапазона.
2) Диапазон может включать в себя отрицательные числа.
3) Можно указать шаг последовательности.

Чтобы указать величину шага, передают три значения: левую границу, правую границу и шаг.

    step_size_2 = range(1, 7, 2)
    # Указали начало последовательности (1), её конец (7) и шаг = 2
    # step_size_2 будет включать числа 1, 3, 5

4) Диапазон можно перебирать в цикле.

Для последовательности внутреннюю переменную цикла традиционно называют i. Но её можно назвать как угодно.

Задать диапазон можно сразу в условии цикла. Не обязательно создавать промежуточную переменную.

    # Цикл переберёт все числа в диапазоне от -3 до 3 и напечатает их:
    for i in range(-3, 3):
        print(i)

    # Результат будет тот же

#### Функция reversed()

Функцию reversed() используют, когда нужно пройтись по последовательности в обратном порядке. 

    for i in reversed(range(1, 13)):
        print(i, 'бомм!')

    print('C новым годом!')

или

    # Можно обратить вспять обычный список: 
    seasons = ['зима', 'весна', 'лето', 'осень']

    for season in reversed(seasons):  
        # Внутреннюю переменную цикла назвали season
        print(season)

    # Будет напечатано: 
    # осень
    # лето
    # весна
    # зима

## 8. Срез списка

Срез (на англ. «slice» — кусочек) создаёт подмножество внутри списка. Скажем, был список от 1 до 20. Из него выбрали кусочек — от 5 до 10. Это и будет срез.

Чтобы создать срез, нужно:
- Указать имя списка. Например, buttons.
- Поставить квадратные скобки [].
- В скобках передать аргументы через двоеточие. Аргументы в таком порядке: индекс начала, индекс конца, величина шага.

    buttons = ['Отели', 'Авиа', 'Ж/д', 'Автобусы', 'Туры'] 

    print(buttons[1:4:2])
    # Индекс начала — индекс второго элемента
    # Индекс конца — индекс последнего элемента списка
    # Указали индекс «Туры», но элемент не попадёт в срез
    # Шаг = 2

    # Будет напечатано: ['Авиа', 'Автобусы']

❌ Последний индекс среза в него не входит.

Значения по умолчанию для среза:
1) Если шаг равен единице, его не указывают.
2) Если индексы начала и конца среза совпадают с индексами первого и последнего элемента списка, их тоже не указывают.

    buttons = ['Отели', 'Авиа', 'Ж/д', 'Автобусы', 'Туры'] 

    print(buttons[::2])
    # Указали только величину шага
    # Срез будет включать первый элемент и каждый третий

    # Будет напечатано: ['Отели', 'Ж/д', 'Туры']

    print(buttons[1:])
    # Указали начало среза 1, чтобы исключить первый элемент списка
    # Шаг автоматически = 1

    # Будет напечатано: ['Авиа', 'Ж/д', 'Автобусы', 'Туры']

    print(buttons[1]) # А вот это уже не срез
    # Это вызов значения элемента по индексу
    # За двоеточиями в срезе стоит внимательно следить

    # Будет напечатано: Авиа

#### Обратный срез списка

Величина шага в срезе может быть отрицательным числом. Например, numbers[::-1]. Если напечатать такой срез, код выведет на экран весь список в обратном порядке.

    numbers = [1, 2, 3, 4, 5]

    reversed_numbers = numbers[::-1]

    print(reversed_numbers)
    # Будет напечатано: [5, 4, 3, 2, 1]

    print(numbers[::-1]) # Можно и без промежуточной переменной
    # Результат будет тот же
    # Будет напечатано: [5, 4, 3, 2, 1]

## 9. Вложенные циклы

    rooms_floor1 = ['Номер 1', 'Номер 2', 'Номер 3', 'Номер 4']
    rooms_floor2 = ['Номер 5', 'Номер 6', 'Номер 7', 'Номер 8']
    rooms_floor3 = ['Номер 9', 'Номер 10', 'Номер 11', 'Номер 12']

    hotel_floors = [rooms_floor1, rooms_floor2, rooms_floor3]

    for floor_rooms in hotel_floors: # Запустили внешний цикл по списку hotel_floors
        # тело внешнего цикла
        for room in floor_rooms: # Создали вложенный цикл для хождения по списку номеров, который записан в переменную
            # тело вложенного цикла
            print('Убрать', room) # Вывели номер номера на каждом шаге вложенного цикла
        # тело внешнего цикла
        print('Подняться на этаж выше') # Вывели сообщение о переходе на следующий этаж на каждом шаге внешнего цикла

## 10. Ключевые слова break и continue в циклах

#### Пропуск итерации цикла: continue

    sheep = [1, 2, 3, 4, 5]

    for i in sheep: # Внешний цикл
        if i == 3: # Вложенное условие: если переменная = 3,
            continue # итерацию нужно пропустить
        print(i, 'овечка') 

    print('А куда пропала одна овечка?') # Эта строка не относится к циклу

#### Выход из цикла: break

Если использовать ключевое слово во вложенном цикле, оно будет относиться только к нему. И на работу внешнего цикла не повлияет.


## 11. Длина строки, индексы и подстроки

У строк много общего со списками. Если список — это последовательность элементов, то строка — последовательность символов.

Любой символ строки можно получить по индексу. Для этого в квадратных скобках после строки указывают индекс нужного символа. Например, вот так:

    s = 'строка'

    print(s[0])  # c
    print(s[1])  # т

    print(s[-2]) # к
    print(s[-len(s)]) # c

    print(s[len(s)])  # Будет выведена ошибка IndexError, так как индекс за пределами строки
    # А вот так ошибки не будет:
    print(s[len(s) - 1])  # а

Строки — неизменяемые объекты. Поэтому нельзя заменить символ в строке по его индексу.

В строках можно выделять подстроки. Подстрока — это любой фрагмент строки. Например, 'снег'  и 'ад' в  строке'снегопад'.

С помощью индексов можно получать и более крупные подстроки. Такой способ называют получением подстроки с помощью среза. В этом случае подстрока — срез оригинальной строки.

Чтобы получить срез, нужно записать имя строки. После него поставить квадратные скобки и указать в них:

- индекс первого символа среза;
- двоеточие :;
- индекс на единицу больше, чем индекс последнего символа среза.

Не забывай: последний элемент среза в него не входит. Поэтому нужно увеличивать значение на единицу.

    a = 'Жил-был в норе под землей хоббит'

    print(a[0:3])  # Жил
    print(a[4:7])  # был

#### Оператор in

Используется аналогично списку, но есть нюансы:

- Регистр букв имеет значение. Для Python 'Баг' и 'баг' — это не одно и то же. Записывай подстроку точно, иначе получишь недостоверный результат.
- Если ищешь в строке число, записывай его как строку. Не забывай про кавычки. Например, '7'. Это нужно для совместимости типов данных.

## 12. Метод split()
Используется для разбиения большой строки на подстрои или отдельные слова.

Чтобы его вызвать:
- Укажи имя строки. Например, line.
- Поставь точку и напиши имя метода: line.split().
- В круглые скобки передай разделитель. Например, line.split(',').

В результате получится список. Подстроки станут его значениями.
Список можно записать в переменную и дальше работать с ней.

Особенности:
- Разделитель не сохраняется в список. 
- Если оставить скобки пустыми по умолчанию разделитель будет пробел

## 13. Метод replace()

Данный метод меняет с строке одну подстрок на другуюю
Ошибки не будет: replace() создаёт копию строки и вносит изменения уже в неё. Исходная строка останется неизменной.

Чтобы его использовать:
1) Запиши имя строки. Например, quote.
2) Поставь точку и укажи имя метода replace().
3) В метод передай через запятую:
- первым аргументом — подстроку, которую нужно заменить. Например, 'Нельзя'.
- вторым аргументом — подстроку, которая должна её заменить. Например, 'Можно'.

    quote = 'Нельзя просто так взять и войти в Мордор'

    new_quote = quote.replace('Нельзя', 'Можно')

    print(new_quote)
    # Можно просто так взять и войти в Мордор

    print(quote)
    # Нельзя просто так взять и войти в Мордор

Иногда указывают ещё третий аргумент — количество совпадений. Но это делать не обязательно. Его используют, только если нужно заменить часть совпадений.

    quote2 = 'Из них вывозят и вывозят куда-то мебель, ковры, картины, цветы, растения.'

    new_quote2 = quote2.replace('вывозят', 'выносят', 1)

    print(new_quote2)
    # Из них выносят и вывозят куда-то мебель, ковры, картины, цветы, растения.
# Метод произвёл замену один раз

Особенности:
1) метод можно использовать для удаления подстрок
2) метод можно использовать повторно

    s = 'http://www.practicum.yandex.com/%20profile/'

    # много разных замен, читать неудобно
    new_s = s.replace('http', 'https').replace('www.', '').replace('com', 'ru').replace('%20', '')

    print(new_s)
    # 'https://practicum.yandex.ru/profile/'

## 14. Словари и коллекции

Словарь — это набор парных значений. Каждый элемент словаря состоит из двух частей: первая — ключ, вторая — значение. Их разделяют двоеточием.

    shopping_list = {
        'молоко': 'milk', # Первый элемент словаря (в каждом элементе две части!)
        'сахар': 'sugar',  # Второй элемент словаря
        'мука': 'flour',  # Третий элемент
        'яйца': 'eggs',  # Четвёртый элемент
        'разрыхлитель': 'leaven',  # Пятый элемент
        'ваниль': 'vanilla'
    }

Ключи — уникальны, значения — нет.

Ключами словаря могут быть: 
числа,
строки,
булевы значения True и False

При этом в словаре не может быть двух одинаковых ключей. Ключ — это уникальный адрес, по которому можно найти значение, поэтому он не может повторяться. 

Значением может быть что угодно: числа, строки, списки и даже другие словари. 

Списки и словари относят к одному виду конструкций — коллекциям.

Коллекция — это набор значений, которые хранятся вместе и к которым можно применять специальные функции.

Чтобы получить значение из словаря в Python, нужно указать его ключ. Это ещё называют получить доступ по ключу.

    shopping_list = {
        'молоко': 'milk',
            'сахар': 'sugar',
        'мука': 'flour',
        'яйца': 'eggs',
            'разрыхлитель': 'baking powder',
            'ваниль': 'vanilla'
    }

    print(shopping_list['мука'])

можно заменить значение словоря.

    shopping_list['мука'] = 'agony'

Чтобы добавить элемент, нужно написать такую же конструкцию, только с новым ключом и значением.

    shopping_list = {
        'молоко': 'milk',
        'сахар': 'sugar',
        'мука': 'flour',
        'яйца': 'eggs',
        'разрыхлитель': 'leaven',
        'ваниль': 'vanilla'
    }

    # Создаём новый элемент словаря через доступ по ключу
    shopping_list['клубника'] = 'strawberries' 

Если ключ уже существует в словаре, эта команда заменит его значение. Если такого ключа ещё нет — добавится новый элемент.

Если добавить в словарь несколько элементов с одинаковыми ключами, но разными значениями — в словаре появится только один элемент с этим ключом. Ему присвоится последнее из добавленных значений.

#### update()

update() - позволяет объединить два словаря: добавить в один словарь элементы другого.

    shopping_list = {
        'молоко': 'milk',
        'сахар': 'sugar',
        'мука': 'flour',
        'яйца': 'eggs',
        'разрыхлитель': 'leaven',
        'ваниль': 'vanilla'
    }

    # новый словарь
    additional_products = {'клубника': 'strawberries', 'малина': 'raspberries'}

    # Добавим в словарь shopping_list элементы словаря additional_products
    shopping_list.update(additional_products)

    # Посмотрим, что теперь хранится в словаре shopping_list
    print(shopping_list)

    # Заодно выясним, что произошло со словарём additional_products
    print(additional_products)

    